\documentclass[runningheads]{llncs}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}

\begin{document}

\title{PRISM: Verificación Formal de Sistemas con Modelos Probabilísticos}

\author{
    Angeles Carrara\and
    Julieta Paola Storino\and
    Mateo Carranza Velez}

\authorrunning{Carrara, Storino, Carranza-Velez}

\institute{
    Facultad de Matemática, Astronomía, Física y Computación.\\
    Universidad Nacional de Córdoba.
    \email{\{mateocvelez,julieta\_storino,angeles.carrara\}@mi.unc.edu.ar}}

\maketitle

\begin{abstract}
Este documento presenta una introducción a la herramienta PRISM\cite{KNP11}, un entorno para el modelado y análisis formal de sistemas con comportamientos aleatorios o probabilísticos, que permite la verificación rigurosa de propiedades cuantitativas y cualitativas sobre modelos como cadenas de Markov (discretas y continuas), procesos de decisión de Markov y autómatas probabilísticos. Se abordan los principales aspectos relacionados con su desarrollo y aplicación, incluyendo: el contexto de creación de la herramienta, sus objetivos fundamentales, una descripción de sus funcionalidades desde la perspectiva del usuario, los componentes técnicos que la sustentan, casos de estudio documentados —tanto exitosos como con limitaciones—, una comparación con otras herramientas similares en el ámbito de la verificación formal, y un análisis detallado de un caso de estudio seleccionado.
\end{abstract}

\section{Introducción}

Los sistemas informáticos se encuentran cada vez más integrados en múltiples áreas del conocimiento, enfrentando riesgos cada vez más críticos y de mayor impacto. Estos riesgos abarcan desde errores que pueden poner en peligro vidas humanas —como sobredosis de radiación provocado por condiciones de carrera en sistemas médicos \cite{LT93}—, hasta pérdidas económicas multimillonarias —como autodestrucción en cohetes espaciales provocado por conversión incorrecta de punto flotante a entero en sistemas de referencia inercial \cite{Lan96}—. Frente a esta realidad, se vuelve esencial garantizar sistemas más robustos, confiables y con una tolerancia al fallo mínima. Para ello, es necesario recurrir a modelos formales que permitan describir con precisión las partes relevantes del sistema, conservando un nivel de abstracción que facilite su análisis y verificación.

\section{Antecedentes}

Existen diversas técnicas para verificar la corrección funcional de un sistema, entre las que se incluyen la demostración de teoremas, la simulación, la prueba (testing), y la verificación de modelos (model checking). En nuestro informe, nos enfocamos en esta última, una técnica que consiste en explorar exhaustivamente todos los estados posibles del sistema mediante un enfoque de fuerza bruta, con el objetivo de comprobar que un modelo dado cumple efectivamente con una propiedad específica \cite{BK07}. Este enfoque tradicional de verificación de modelos busca proporcionar una garantía completamente precisa sobre el cumplimiento —o no— de una propiedad en el modelo analizado. Sin embargo, en muchos escenarios no es posible ni deseable ofrecer garantías absolutas. Por ejemplo, en protocolos de comunicación o redes inalámbricas, es necesario considerar una cierta probabilidad de pérdida de mensajes.

La verificación de modelos probabilísticos (Probabilistic Model Checking) es una extensión de la verificación de modelos clásica que nos permite establecer la validez de una propiedad dentro de un modelo dado. Es una técnica automática de verificación formal diseñada para analizar sistemas que presentan comportamientos estocásticos.
A diferencia de la verificación tradicional, cuyo resultado es estrictamente booleano (la propiedad se cumple o no), la verificación probabilística permite obtener valores cuantitativos, como la probabilidad de alcanzar un estado crítico o el tiempo esperado hasta que ocurra un evento. Esta capacidad resulta especialmente útil en el análisis de sistemas que interactúan con entornos inciertos, como redes de comunicación, sistemas embebidos y protocolos distribuidos.

Para comprobar el modelo de un sistema que muestra un comportamiento estocástico, primero necesitaremos construir un modelo probabilístico formal de ese sistema. Existen varias representaciones de modelos probabilísticos de uso común para sistemas estocásticos, pero nos vamos a enfocar en los principales modelos soportados por la herramienta a desarrollar.

\textbf{Cadenas de Markov de Tiempo Discreto (DTMC)}: Son modelos en los que el comportamiento del sistema evoluciona en pasos discretos, y en cada paso existe una distribución de probabilidad sobre los posibles estados siguientes. Se representan como grafos dirigidos etiquetados con probabilidades de transición. Para cada estado, las probabilidades de transición deben sumar $1$\cite{KNP02}. Estos modelos son apropiados para sistemas donde el tiempo se modela como secuencias de eventos discretos y completamente probabilísticos, como protocolos de comunicación simples o sistemas sin decisiones controlables.

\textbf{Procesos de Decisión de Markov (MDP)}: Extienden DTMC introduciendo no determinismo, lo que permite modelar elecciones o decisiones controlables dentro del sistema. En cada estado, el sistema puede tener varias acciones posibles, y cada acción induce una distribución de probabilidad sobre los estados sucesores. Este modelo es útil para representar la interacción entre el entorno (probabilístico) y un controlador (no determinista). Permiten modelar, por ejemplo, sistemas con múltiples componentes que operan en paralelo de manera asincrónica, donde ciertas decisiones dependen del contexto de ejecución.

\textbf{Cadenas de Markov de Tiempo Continuo (CTMC)}: Las transiciones entre estados ocurren después de un tiempo continuo aleatorio, no en pasos discretos. Cada transición está asociada con una tasa que determina la probabilidad de moverse de un estado a otro en un cierto tiempo, siguiendo una distribución exponencial. Este tipo de modelos es adecuado para analizar sistemas donde los eventos ocurren de forma continua en el tiempo, como redes de colas o sistemas biológicos.

\textbf{Autómatas Temporizados Probabilísticos (PTAs)}: Combinan aspectos de los MDP (no determinismo y probabilidad) con restricciones temporales explícitas sobre el comportamiento. Se modelan con relojes (clocks) que evolucionan en tiempo real, y las transiciones pueden depender de condiciones temporales (por ejemplo, \textit{esperar al menos 5 segundos antes de enviar un mensaje}). Esto permite representar sistemas donde el tiempo es un recurso fundamental y las decisiones deben tomarse en ventanas temporales específicas, como en protocolos de red con tiempos límite o sistemas embebidos con control en tiempo real.

Una vez que el sistema está representado por un modelo, queremos comprobar si este cumple una especificación formal. Para ello, PRISM permite expresar propiedades utilizando diversos lenguajes de lógica temporal, pero nuevamente nos enfocaremos en el más representativo: la Lógica de Árbol Computacional Probabilística (PCTL).

\textbf{Lógica de Árbol Computacional Probabilística (PCTL)}: Es introducida por Hansson y Jonsson en \cite{HH94} como una extensión probabilística de la lógica temporal CTL. Su característica distintiva es el uso del operador probabilístico $P$, que generaliza los cuantificadores $\forall$ y $\exists$ de CTL para incorporar condiciones sobre la probabilidad de ocurrencia de ciertos eventos en un sistema estocástico. Por ejemplo, la fórmula
\[a\to P_{\le p}[F^{\le s} b]\]
se interpreta como "si $a$ ocurre, entonces la probabilidad de que $b$ ocurra en los próximos $s$ pasos es menor o igual a $p$". La sintaxis de PCTL se divide en fórmulas de estado y fórmulas de camino, definidas de la siguiente manera:

\begin{itemize}
    \item \textit{Fórmulas de estado}: \( \phi ::= \text{true} \mid a \mid \phi \land \phi \mid \neg \phi \mid P_{\sim p}[\psi]\)
    \item \textit{Fórmulas de camino}: \(\psi ::= X\ \phi \mid \phi \ U^{\leq k} \psi \mid \phi \ U \phi \mid F\ \phi \mid G\ \phi\)
\end{itemize}
Donde:
\begin{itemize}
    \item\(a\) es una proposición atómica,
    \item\(p \in [0,1]\) es un umbral de probabilidad,
    \item\(\sim \in \{<, >, \leq, \geq\}\) es un operador de comparación,
    \item\(k \in \mathbb{N}\) indica una cota temporal (en pasos discretos).
    \item \(X=next\), \(F=future\), \(G=globally\), \(U=until\).
\end{itemize}

\section{Descripción de la herramienta del lado del usuario}

Prism es una herramienta que cuenta con interfaz gráfica, pero que también puede usarse sobre línea de comando. La interfaz gráfica está compuesta por cuatro pestañas cada una con una función diferente. Estas son 'Model', 'Properties', 'Simulator' y 'Log'.

En la pestaña 'Model' es donde se especifica el modelo, en el lenguaje PRISM. En la primera línea debemos indicar el modelo probabilístico que vamos a utilizar. Este puede ser 'dtmc', 'ctmc', 'mdp', 'pta', 'pomdp' o 'popta'. Un modelo (no confundir con los modelos nombrados recién) en Prism está formado por uno o más módulos. Cada módulo contiene variables, que describen el estado del módulo. Dentro de cada módulo, se describen sus transiciones, que dependen del estado actual del módulo, y posiblemente de otros módulos. En DTMC o MDP, cada transición describe la probabilidad de de pasar de un estado a otro. En CTMC, hay que especificar tasas en lugar de probabilidades. También cuenta con un sistema de costos y recompensas.
Para una descripción más detallada del lenguaje, leer la documentacón [TODO: poner ref]

En la pestaña 'Properties' es donde se especifican las propiedades que que queremos verificar. Estas deben escribirse en el lenguaje de especificación de propiedades PRISM, que soporta varias lógicas temporales probabilísticas, tales como PCTL, CSL, LTL probabilístico y PCTL*. Estas propiedades pueden ser de tipos. En las del primer tipo, le preguntamos al modelo si cierta propiedad es cierta o no. Por ejemplo, que la probabilidad de llegar a cierto estado es mayor o igual a 0.5. En las del segundo tipo, le pedimos al modelo que calcule algún valor. Por ejemplo, la probabilidad de llegar a cierto estado o tiempo esperado hasta que ocurra algo. Para calcular estos valores esperados se usan los costos y recompensas.
Para una descripción más detallada del lenguaje, leer la documentacón [TODO: poner ref]

En la pestaña 'Simulator' podemos realizar simulaciones del modelo. En estas simulaciones, podemos decirle a la herramienta que haga una cantidad específica de pasos aleatoriamente o podemos elegir nosotros manualmente las transiciones. Cuenta con una tabla que nos permite ver los valores de las variables en cada paso. También se pueden generar gráficos de estas simulaciones.

La herramienta permite visualizar los modelos, mediante de la generación de archivos .dot de los grafos asociados a los modelos.

PRISM permite también especifcar propiedades no probabilísticas, en CTL o LTL y es capaz de reportar contraejemplos cuando una propiedad no se cumple.


\begin{thebibliography}{8}

\bibitem{KNP11}
Kwiatkowska, M., Norman, G., Parker, D.: PRISM 4.0: Verification of Probabilistic Real-time Systems. In: Gopalakrishnan, G., Qadeer, S. (eds.) CAV 2011. LNCS, vol. 6806, pp. 585--591. Springer, Heidelberg (2011)

\bibitem{KNP02}
Kwiatkowska, M., Norman, G., Parker, D.: PRISM: Probabilistic Symbolic Model Checker. In: Field, T., Harrison, P.G., Bradley, J.T., Harder, U. (eds.) TOOLS 2002. LNCS, vol. 2324, pp. 200--204. Springer, Heidelberg (2002)

\bibitem{BK07}
Baier, C., Katoen, J.-P.: Principles of Model Checking. MIT Press, Cambridge (2007)

\bibitem{LT93}
Leveson, N.G., Turner, C.S.: An Investigation of the Therac-25 Accidents. IEEE Computer \textbf{26}(7), 18--41 (1993)

\bibitem{Lan96}
Le Lann, G.: The Ariane 5 Flight 501 Failure -- A Case Study in System Engineering for Computing Systems. Rapport de recherche \textbf{3079} (1996)

\bibitem{HH94}
Hansson, H., Jonsson, B.: A Logic for Reasoning about Time and Probability. Formal Aspects of Computing \textbf{6}(5), 512--535 (1994)

\end{thebibliography}
\end{document}